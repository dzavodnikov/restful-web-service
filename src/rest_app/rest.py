from rest_app import get_storage
from rest_app.domain import Book, BookUpdate, BookNotFoundException

from fastapi import FastAPI, Request
from fastapi.openapi.utils import get_openapi
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles

from pydantic import BaseSettings
from typing import List


class Settings(BaseSettings):
    storage_type: str = "sqlite:data/book_storage.db"


setting = Settings()
app = FastAPI()
book_storage = get_storage(setting.storage_type)


@app.exception_handler(BookNotFoundException)
async def book_not_found_exception(_request: Request, exc: BookNotFoundException):
    return JSONResponse(status_code=404, content={"message": f"Book with ID {exc.book_id} not found"})


@app.get(
    "/book/list",
    description="""Return the list of books. You are also can filter by book records, like an 'author', 'title' and 
    date of publishing (parameters 'published_date_from' and 'published_date_to'). For 'author' and 'title' you are 
    also can use primitive regular expressions: '?' for any one symbol and '*' for zero or many any symbols.""")
async def book_list(
        author: str = None,
        title: str = None,
        published_date_from: str = None,
        published_date_to: str = None) -> List[Book]:
    return book_storage.list(
        author,
        title,
        BookUpdate.parse_date_str(published_date_from),
        BookUpdate.parse_date_str(published_date_to)
    )


@app.post("/book", description="Create an new book record.")
async def book_add(book: BookUpdate) -> Book:
    persist_book = book_storage.create(book)
    return persist_book


@app.delete("/book/{book_id}", description="Delete existing book record. Use Book ID that generated by storage.")
async def book_delete(book_id: int) -> Book:
    persist_book = book_storage.find(book_id)
    book_storage.remove(persist_book.id)
    return persist_book


@app.put("/book/{book_id}", description="Update existing book record. Use Book ID that generated by storage.")
async def book_update(book_id: int, update: BookUpdate) -> Book:
    persist_book = book_storage.find(book_id)

    update_dict = update.dict()
    for field_name in update_dict.keys():
        field_value = update_dict[field_name]  # Extract new value...
        if field_value:  # ...if value is defined...
            setattr(persist_book, field_name, field_value)  # ...update existing object.
    book_storage.persist(persist_book)

    return persist_book


def custom_openapi():
    if app.openapi_schema:  # If was cached...
        return app.openapi_schema  # ...return cache.

    # Create schema at first time...
    openapi_schema = get_openapi(
        title="RESTful Web Service",
        version="1.0.0",
        description="This is a very simple RESTful Web Service",
        routes=app.routes
    )
    app.openapi_schema = openapi_schema  # ...and cache it.
    return app.openapi_schema


app.openapi = custom_openapi


# To prevent overrode existing REST APIs.
app.mount("/css", StaticFiles(directory="resources/css"))
app.mount("/js", StaticFiles(directory="resources/js"))
app.mount("/img", StaticFiles(directory="resources/img"))
# Should be last one to prevent catching other resources.
app.mount("/", StaticFiles(directory="resources/html", html=True))
